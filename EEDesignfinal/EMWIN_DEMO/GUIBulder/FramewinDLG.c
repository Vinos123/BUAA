/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.26                          *
*        Compiled Aug  8 2014, 14:49:54                              *
*        (c) 2013 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
#include "AD9854.h"
#include "math.h"
//#include "adc.h"
#include "includes.h"
#include "GRAPH.h"
#include "stdlib.h"
#include "stdio.h"
#include "ctype.h"
#include "usart.h"
// USER END

#include "DIALOG.h"

/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_FRAMEWIN_0   (GUI_ID_USER + 0x00)
#define ID_GRAPH_0   (GUI_ID_USER + 0x01)
#define ID_BUTTON_0   (GUI_ID_USER + 0x02)
#define ID_EDIT_0   (GUI_ID_USER + 0x03)
#define ID_EDIT_1   (GUI_ID_USER + 0x04)
#define ID_BUTTON_1   (GUI_ID_USER + 0x05)
#define ID_EDIT_2   (GUI_ID_USER + 0x06)
#define ID_EDIT_3   (GUI_ID_USER + 0x09)
#define ID_BUTTON_2   (GUI_ID_USER + 0x0A)
#define ID_BUTTON_3   (GUI_ID_USER + 0x0B)
#define ID_DROPDOWN_0   (GUI_ID_USER + 0x0C)
#define ID_TEXT_0   (GUI_ID_USER + 0x0D)
#define ID_TEXT_1   (GUI_ID_USER + 0x0F)
#define ID_TEXT_2   (GUI_ID_USER + 0x10)
#define ID_EDIT_4   (GUI_ID_USER + 0x11)
#define ID_BUTTON_4   (GUI_ID_USER + 0x12)


// USER START (Optionally insert additional defines)

// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

// USER START (Optionally insert additional static data)
static GRAPH_SCALE_Handle hScaleH;//水平刻度句柄
static GRAPH_SCALE_Handle hScaleV;//垂直刻度句柄
//static GRAPH_DATA_Handle pdataGRP;//数据句柄
int mod=-1;//标志基础任务和发挥任务的模式，初始为3，不进入其他状态
static GUI_POINT _aPoint[1];//输入数据为点阵（包含横坐标x,纵坐标y的结构体）
//extern int ADC_store_PP[200];
static GRAPH_DATA_Handle hDataXY;
char s2show[10];
//extern int Gain_graph[200];
extern int ADC_store_P[200];
extern int ADC_store_N[200];
int ADC_store_PP[200];
int fc=0;//截止频率
char s2show[];
int count_size=0;
int judge = 0;
extern int ADC_Res_In_PP[2];
extern int ADC_Res_Out_PP[2];
float Res_out=0;
float Res_in=0;
float ADC_IN_cal_P[2],ADC_IN_cal_N[2],ADC_OUT_cal_P[2],ADC_OUT_cal_N[2];
float ADC_IN_cal_PP[2],ADC_OUT_cal_PP[2];
extern int ADC_Res_In_P[2];
extern int ADC_Res_In_N[2];
extern int ADC_Res_Out_P[2];
extern int ADC_Res_Out_N[2];
extern int ADC_DC[5];
int DC_flag=0;
int ADC_aver=0;
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { FRAMEWIN_CreateIndirect, "Circuit Tester", ID_FRAMEWIN_0, 0, 0, 800, 480, 0, 0x0, 0 },
  { GRAPH_CreateIndirect, "Graph", ID_GRAPH_0, -13, 1, 493, 436, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Input Resistance", ID_BUTTON_0, 641, 79, 147, 55, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "Edit", ID_EDIT_0, 485, 79, 148, 54, 0, 0x64, 0 },//输入电阻
  { EDIT_CreateIndirect, "Edit", ID_EDIT_1, 486, 145, 148, 54, 0, 0x64, 0 },//输出电阻
  { BUTTON_CreateIndirect, "Output Resistance", ID_BUTTON_1, 641, 144, 147, 55, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "Edit", ID_EDIT_2, 643, 250, 148, 54, 0, 0x64, 0 },//增益
  { EDIT_CreateIndirect, "Edit", ID_EDIT_3, 486, 251, 148, 54, 0, 0x64, 0 },//截止频率
  { BUTTON_CreateIndirect, "Part A", ID_BUTTON_2, 558, 4, 148, 54, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "Button", ID_BUTTON_3, 36, -68, 80, 20, 0, 0x0, 0 },
  { DROPDOWN_CreateIndirect, "Dropdown", ID_DROPDOWN_0, 1430, 222, 80, 19, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Gain", ID_TEXT_0, 521, 214, 80, 32, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "Text", ID_TEXT_1, 279, 74, 80, 20, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "fc", ID_TEXT_2, 676, 215, 80, 32, 0, 0x0, 0 },
  { EDIT_CreateIndirect, "Edit", ID_EDIT_4, 482, 379, 305, 50, 0, 0x64, 0 },
  { BUTTON_CreateIndirect, "Part B", ID_BUTTON_4, 566, 318, 148, 54, 0, 0x0, 0 },
  // USER START (Optionally insert additional widgets)
  // USER END
};

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

// USER START (Optionally insert additional static code)

//extern 
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  WM_HWIN hItem;
  int     NCode;
  int     Id;
  // USER START (Optionally insert additional variables)
  // USER END

  switch (pMsg->MsgId) {
  case WM_INIT_DIALOG:
    //
    // Initialization of 'Circuit Tester'
    //
    hItem = pMsg->hWin;
    FRAMEWIN_SetTitleHeight(hItem, 40);
    FRAMEWIN_SetFont(hItem, GUI_FONT_32B_ASCII);
    FRAMEWIN_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'Input Resistance'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
    BUTTON_SetFont(hItem, GUI_FONT_16B_ASCII);
    //
    // Initialization of 'Edit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_0);
    EDIT_SetText(hItem, "");
    EDIT_SetFont(hItem, GUI_FONT_24B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'Edit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_1);
    EDIT_SetText(hItem, "");
    EDIT_SetFont(hItem, GUI_FONT_24B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'Output Resostance'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
    BUTTON_SetFont(hItem, GUI_FONT_16B_ASCII);
    //
    // Initialization of 'Edit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_2);
    EDIT_SetText(hItem, "");
    EDIT_SetFont(hItem, GUI_FONT_24B_ASCII);
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'Edit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_3);
    EDIT_SetText(hItem, "");
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    EDIT_SetFont(hItem, GUI_FONT_24B_ASCII);
    //
    // Initialization of 'Part A'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
    BUTTON_SetFont(hItem, GUI_FONT_24B_ASCII);
    //
    // Initialization of 'Gain'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
    TEXT_SetFont(hItem, GUI_FONT_24B_ASCII);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    //
    // Initialization of 'fc'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_2);
    TEXT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    TEXT_SetFont(hItem, GUI_FONT_24B_ASCII);
    //
    // Initialization of 'Edit'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_EDIT_4);
    EDIT_SetText(hItem, "");
    EDIT_SetTextAlign(hItem, GUI_TA_HCENTER | GUI_TA_VCENTER);
    EDIT_SetFont(hItem, GUI_FONT_24B_ASCII);
    //
    // Initialization of 'Part B'
    //
    hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_4);
    BUTTON_SetFont(hItem, GUI_FONT_24B_ASCII);
    BUTTON_SetText(hItem, "Part B ");
    // USER START (Optionally insert additional code for further widget initialization)
		//Graph画图
		hItem = WM_GetDialogItem(pMsg->hWin, ID_GRAPH_0);
    GRAPH_SetBorder(hItem, 40, 0, 0, 30);//设置画图的边框
	
		hScaleV = GRAPH_SCALE_Create(30,GUI_TA_RIGHT,GRAPH_SCALE_CF_VERTICAL,25);//设置垂直范围的尺度标签，每25像素一个点
		GRAPH_SCALE_SetTextColor(hScaleV,GUI_RED);//刻度颜色为红色
		GRAPH_AttachScale(hItem,hScaleV);//垂直刻度
		GRAPH_SCALE_SetFactor(hScaleV,0.35);//垂直刻度比例尺
		// GRAPH_SCALE_SetNumDecs(hScaleV,1);//小数点
	
		hScaleH = GRAPH_SCALE_Create(415,GUI_TA_HCENTER,GRAPH_SCALE_CF_HORIZONTAL,50);//设置水平范围的尺度标签，100KHZ分辨率
		GRAPH_SCALE_SetTextColor(hScaleH,GUI_RED);
		GRAPH_AttachScale(hItem,hScaleH);
		GRAPH_SCALE_SetFactor(hScaleH,5);//设置横坐标比例
		GRAPH_SCALE_SetOff(hScaleH,-50);//设置横坐标偏移(右移为正，左移为负，其中偏移的值要考虑比例尺）
		//GRAPH_SCALE_SetNumDecs(hScaleH,0);//设置小数点后显示的位数
	
		//pdataGRP = GRAPH_DATA_XY_Create(GUI_GREEN,200,0,0);//这里频谱需要改成XY
		//GRAPH_AttachData(hItem,pdataGRP);
		hDataXY = GRAPH_DATA_XY_Create(GUI_GREEN,200,0,0);//将AD采样的数据添加到图像中
		GRAPH_AttachData(hItem,hDataXY);
		
		GRAPH_SetGridDistY(hItem,25);
		GRAPH_SetGridFixedX(hItem,1);
		
		GRAPH_SetGridVis(hItem,1);
    // USER END
    break;
  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;
    switch(Id) {
    case ID_BUTTON_0: // Notifications sent by 'Input Resistance'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
			mod=2;//此时改变输入继电器的开闭，测量输入电阻
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_0: // Notifications sent by 'Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_1: // Notifications sent by 'Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_1: // Notifications sent by 'Output Resostance'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
			mod = 3;//此时改变输出继电器的开闭，测量输出电阻
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_2: // Notifications sent by 'Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_3: // Notifications sent by 'Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_2: // Notifications sent by 'Part A'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
			mod = 0;//进入扫频模式，从500Hz开始，同时记录1kHZ时的输出电压峰峰值。
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_3: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_DROPDOWN_0: // Notifications sent by 'Dropdown'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_SEL_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_EDIT_4: // Notifications sent by 'Edit'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      case WM_NOTIFICATION_VALUE_CHANGED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;
    case ID_BUTTON_4: // Notifications sent by 'Part B'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
			mod = 4;
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      } 
      break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
		//增加一个软件定时器，用来采样DAC，判断
		case WM_TIMER://软件定时器部分
			if(WM_IsCompletelyCovered(pMsg->hWin)) break;
			if(mod == 6)//mod=4代表画图完毕的状态
			{
				//printf("%d\n",mod);
				//_InitPoints();
				
				for(count_size=0;count_size<200;count_size++)
				{


				_aPoint[0].x=count_size*2;
				ADC_store_PP[count_size]=ADC_store_P[count_size]-ADC_store_N[count_size];
				_aPoint[0].y=((ADC_store_PP[count_size])/47*3);
				printf("ADC_PP=%d(%d)",ADC_store_PP[count_size],count_size);
				GRAPH_DATA_XY_AddPoint(hDataXY,_aPoint);
				if((ADC_store_PP[count_size]<=ADC_store_PP[7]*0.7)&&(count_size>=5)&&(judge!=1))//寻找截止频率，以3k频率时的幅度作为最大
				{
					fc=count_size;
					sprintf(s2show,"%dkHz",fc);
					hItem = WM_GetDialogItem(pMsg -> hWin, ID_EDIT_2);
					EDIT_SetText(hItem,s2show);
					judge =1 ;
				}
				hItem=WM_GetDialogItem(pMsg -> hWin, ID_EDIT_3);
				sprintf(s2show,"%dV/V",ADC_store_PP[4]/47);
				EDIT_SetText(hItem,s2show);
				printf("ADC=%d\n",ADC_store_P[count_size]);
				printf("ADC_N=%d\n",ADC_store_N[count_size]);
				ADC_Res_In_PP[0]=ADC_store_PP[2];
				printf("ADC_PP=%d\n",ADC_store_PP[count_size]);
				printf("fc=%d\n",fc);
				}
			}
			//计算输入电阻
			if(mod ==2)
			{
			ADC_IN_cal_P[0]=ADC_Res_In_P[0]*2.0726+145.7;
			ADC_IN_cal_P[1]=ADC_Res_In_P[1]*2.0726+145.7;
			ADC_IN_cal_N[0]=ADC_Res_In_N[0]*2.0902-535.6;
			ADC_IN_cal_N[1]=ADC_Res_In_N[1]*2.0902-535.6;
			ADC_IN_cal_PP[0]=ADC_IN_cal_P[0]-ADC_IN_cal_N[0];
			ADC_IN_cal_PP[1]=ADC_IN_cal_P[1]-ADC_IN_cal_N[1];
			//ADC_Res_In_PP[0]=ADC_store_PP[1];
			Res_in=ADC_IN_cal_PP[1]*2000/(ADC_IN_cal_PP[0]-ADC_IN_cal_PP[1]);
			printf("ADC_resinpp1=%d\n",ADC_Res_In_PP[1]);
			Res_in=Res_in/1000;
			printf("ADC_store1=%d",ADC_store_PP[1]);
			sprintf(s2show,"%3fkohm",Res_in);
			hItem=WM_GetDialogItem(pMsg -> hWin, ID_EDIT_0);
			EDIT_SetText(hItem,s2show);
			}
			//计算输出电阻
			if(mod ==3 )
			{
			ADC_OUT_cal_P[0]=ADC_Res_Out_P[0]*2.0726+145.7;
			ADC_OUT_cal_P[1]=ADC_Res_Out_P[1]*2.0726+145.7;
			ADC_OUT_cal_N[0]=ADC_Res_Out_N[0]*2.0902-535.6;
			ADC_OUT_cal_N[1]=ADC_Res_Out_N[1]*2.0902-535.6;
			ADC_OUT_cal_PP[0]=ADC_OUT_cal_P[0]-ADC_OUT_cal_N[0];
			ADC_OUT_cal_PP[1]=ADC_OUT_cal_P[1]-ADC_OUT_cal_N[1];
			Res_out=(ADC_OUT_cal_PP[0]-ADC_OUT_cal_PP[1])*2000/ADC_OUT_cal_PP[1];
			printf("ADC_PP0=%d,ADC_PP1=%d",ADC_Res_Out_PP[0],ADC_Res_Out_PP[1]);
			Res_out=Res_out/1000;
			sprintf(s2show,"%3fkohm",Res_out);
			hItem=WM_GetDialogItem(pMsg -> hWin, ID_EDIT_1);
			EDIT_SetText(hItem,s2show);
			}
			
			//判断电阻故障
			if(mod == 4)
			{
				for(count_size=0;count_size<2;count_size++)
			{
				if((ADC_DC[count_size]-ADC_DC[count_size+1])/20!=0)
				{
					DC_flag=0;//证明不为直流
				}
				else
				{
					DC_flag=1;//证明为直流
					ADC_aver=(ADC_DC[0]+ADC_DC[1]+ADC_DC[2])/2;
					hItem=WM_GetDialogItem(pMsg -> hWin, ID_EDIT_4);
				}
			}
			if(DC_flag ==1)
			{
				if(ADC_aver<=600)
				{
					EDIT_SetText(hItem,"R4:SC");
					printf("R4:SC=%d",ADC_aver);
				}
				else if(ADC_aver<1000)
				{
					EDIT_SetText(hItem,"R3:OC");
					printf("R3:OC=%d",ADC_aver);
				}
				else if(ADC_aver<4000)
				{
					EDIT_SetText(hItem,"R2:OC");
				}
				else if(ADC_aver<5900&&ADC_aver>4100)
				{
					EDIT_SetText(hItem,"No error");
				}
				else 
				{
					EDIT_SetText(hItem,"R1:SC");
				}
			}
				
			
			}
			//hItem = WM_GetDialogItem(pMsg -> hWin, ID_EDIT_0);
			//EDIT_AddKey(hItem,+48);
			//itoa(ADC_store[10],s2show,10);
			//EDIT_SetText(hItem,s2show);
			//延时函数
			WM_RestartTimer(pMsg->Data.v,4000);
			break;
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateCircuit Tester
*/
WM_HWIN CreateFramewin(void);
WM_HWIN CreateFramewin(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
	WM_CreateTimer(WM_GetClientWindow(hWin),1,4000,0);//创建一个软件定时器
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
